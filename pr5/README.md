## Отчёт по практической работе №5 по дисциплине Технологии и методы программирования

### Задание

Реализовать программу, которая:

1.создает пустое дерево, считывает 4 элемента ai, |ai| <= 2147483647 и заносит их в дерево;

2.выводит дерево (используя функцию print_tree) и пустую строку;

3.считывает 3 элемента ai, |ai| <= 2147483647 и заносит их в дерево;

4.выводит дерево и пустую строку;

5.считывает m1, |m1| <= 2147483647 и ищет элемент с заданным значением в дереве; выводит через пробел значение предка и потомков найденного элемента, если нет значений предка или потомков вывести "_" вместо таких значений;
вывести "-", если элемент не найден; вывести пустую строку;

6.считывает m2, |m2| <= 2147483647 и ищет элемент с заданным значением в дереве; выводит через пробел значение предка и потомков найденного элемента, если нет значений предка или потомков вывести "_" вместо таких значений;
вывести "-", если элемент не найден; вывести пустую строку;

7.считывает m3, |m3| <= 2147483647 и удаляет из дерева элемент с заданным значением (если такой элемент есть);

8.выводит дерево и пустую строку;

9.выполняет левый поворот дерева относительно корня, пока это возможно;

10.выводит дерево и пустую строку;

11.выполняет правый поворот дерева относительно корня, пока это возможно;

12.выводит дерево и пустую строку;

13.выводит на экран количество элементов в дереве и пустую строку;

14.очищает дерево;

15.выводит дерево и пустую строку.

### Ход работы

Ниже функции, которые нужно реализовать работы с бинарным деревом поиска:

```c
// инициализация пустого списка
// Инициализация дерева
void init(tree* t);

// Удалить все элементы из дерева
void clean(tree* t);

// Поиск элемента по значению. Вернуть NULL если элемент не найден
node* find(tree* t, int value);

// Вставка значения в дерево:
// 0 - вставка выполнена успешно
// 1 - элемент существует
// 2 - не удалось выделить память для нового элемента
int insert(tree* t, int value);

// Удалить элемент из дерева:
// 0 - удаление прошло успешно
// 1 - нет элемента с указанным значением
int remove_node(tree* t, int value);

// Удалить минимальный элемент из поддерева, корнем которого является n
// Вернуть значение удаленного элемента
int remove_min(node* n);

// Выполнить правое вращение поддерева, корнем которого является n:
// 0 - успешно выполненная операция
// 1 - вращение невозможно
int rotate_right(node* n);

// Выполнить левое вращение поддерева, корнем которого является n:
// 0 - успешно выполненная операция
// 1 - вращение невозможно
int rotate_left(node* n);

// Вывести все значения из поддерева, корнем которого является n
// по уровням начиная с корня.
// Каждый уровень выводится на своей строке.
// Элементы в строке разделяются пробелом. Если элемента нет, заменить на _.
// Если дерево пусто, вывести -
void print(node* n);

// Вывести все значения дерева t, аналогично функции print
void print_tree(tree* t);

```
Реализованные функии вместе с полным кодом программы находятся в приложении А.

Таблица 1 - Прохождение pipeline:
|Номер программы|Прохождение pipeline|
|-|-|
|1|Да|

Ниже представлен скриншот работы программы.

![](https://sun9-41.userapi.com/impg/3BczGYBxA4iOfcc6oCx_TgyPyoYm8GvAkESeNg/gqBBDPJ1PmM.jpg?size=703x638&quality=96&sign=0b36086f01d5f9fe8a2fc4cf468fb442&type=album)

По полученным результатам можно сделать вывод о том, что все функции работают корректно и программа выполняет поставленную задачу.

Ниже приведён скриншот прохождения программаммами проверки Pipeline.

![](https://sun9-17.userapi.com/impg/PCgANFLZvbFmxQq5pV0V4aEnwS8mMok-58v33w/ZUwcsyKT7Qw.jpg?size=244x201&quality=96&sign=055bca41312845488aada10299fc1496&type=album)




### Заключение
В ходе работы была написана программа, производящая работу с бинарным деревом поиска. Программа прошла првоерку Pipeline.
Программа и отчёт были добавлены в соответствующий репозиторий на сайте [Gitlab](https://gitlab.com).